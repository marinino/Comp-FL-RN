The first step was visting the Flutter and React Native docs. What might be kind of confusing with the React Native documentation is the fact, that are two ways to setup up React Native projects, there is Expo and there is the React Native CLI. It is kind of unclear what is the difference though and at the start, when you are just getting started there might be some confusion. As these differences in the React Native framework will play a role later on I will quickly go over the two approaches, their advantages and when to use them. First of all we will be looking at Expo, basically when generating an Expo project you will get a folder containing you project and a localhost port on which the application is running. Then a mobile device with the Expo Go app installed can be used to connct to the application running. This has the advantage, that there is no emmulator needed on the development machine. In addition to that there is no need to create and configure emulators, which can be time consuming. The downside to this is, that when using an virtual device as an emulator, there is the possibility to test different versions of the operating system and in general different devices with unique properties. In comparison to the React Native CLI approach the Expo approach has plenty of advantages, first of all you can create a project with prebuilt libraries . This can be useful if you create plenty of similar projects which all have similar dependecies, which you can include in a template in order for the projects to always be created equally. Furthermore the build proccess is a simpler in Expo from a developer standpoint, as Expo handles the build proccess on its own, the developer does not need to worry about that. A very nice thing about Expo is that apps can be build for IOS and Android no matter the development device is. So for exmaple a IOS application can be created on a Windows device, which normally is not possible. And as already mentioned it is really is to connect physical devices and let your application run on that. Obviously there are some downside to using Expo, the first big disadvantage is that expo only allows you to use a limited amount of native modules. For example the filesystem module or webviews do not really work in expo. This may lead to some issues, when using certain third-party libraries, which can be turn out to be a big problem, especially in bigger applications. As already mentioned Expo performs the build proccess completly on its own, which can be good in certain situations but obviously there is a loss of control from a developer standpoint. So that feature can also be taken as a disadvantage, depending on the situation. Something may seem weird in the first place is that Expo apps tend to be larger in bundle size.  On the first look, the expo projects seems really compact and more lightweight in comparison to a React Native CLI, but the larger size of the Expo project can have negative effects on things like download and loading times. Personally I experienced that issue with accessing the file system in Expo, after some googleing you will eventually find out what the issue is, but in the first place that is really confussing, because as in the beginning you may actaully completly miss the fact that there actually is a differnce between Expo and the React Native CLI. Now look at the React Native CLI, the first big advantage is that there are no restrictions on using any native modules, which widens the realms of what you can do a lot. The devloper has complete control over the build, this can be helpful if the developer is very experienced or if some modifications in the build mesut be done. There is also a much bigger ecosystem and tool support for the React Native CLI, and in constrast to Expo there is no restriction on third party libraries. The problem with all the above is that this steepens the leraning curve a lot, especially for a beginner Expo creates a much easier starting point a lower entry bar. In addition to that the setup takes time, this is again something which is not an issue for an experienced developer as the initial setup might not take that much time, but for beginners that may be an issue. The same thing goes for the build proccess, which is in contrast to Expo not automated. Maybe the biggest disadvantage is that the EAS does not work with the React Native CLI, so in order the create an IOS application you need a Macbook. Now the question is what approach works better in which scenario? Well simply but, Expo is more beginner friendly and the React Native CLI is for more experienced developers. Another case in which Expo would be a good choice is something like quick prototyping, when you just try to create quick little examples and deep functionality Expo offers first of all the comfort of the template for creating similar projects multiple times and the quick set up helps to just run the application with no big configuration work. In addition to that is Expo are good approach if no low-level device features are used. Low-level device features are things like the camera, GPS, access to the filesystem and so on and so forth. If simplicity is more important in your development proccess than customizability then again Expo is a good idea. This may be the case for internal projects or for a mock application or something like that. But as Expo can be seen as kind of limited, you could say as soon as are real application is vuild for a costumer Expo is already not an option any more. Because as soon as you need a third party library or one of the low-level device features mentioned above, using React Native CLI is a necesity. The same goes obviously for customizing the build proccess or performance optimizations of some sort. Now shortly to the setup of the two IDEs being used in the development proccess. Flutter was conded in Android Studio from the start, the checkers game in React Native was also coded in Android Studio. The setup Android studio setup was pretty easy as the setup was already done. Setting up an IDE alsways has its difficulties and there some things which need to be taken into account setting up Android Studio, with environment variables and getting the emulators to run but in general the general setup is not more difficult or easy than any other IDE. Something that caught my eye with Android Studio was the fact, that the updates for the IDE had to be done manually, which is kind of weird in my eyes and I would generally not pick Android Studio as a very good IDE. The big advantage of Android studio though is the easy use of emulators. In combination with the hot reload feature of Flutter development is pretty easy. So in this very case Android Studio has some big advantages for mobile development. The Expo applications were coded in Visual Studio Code and the connection with the physical device was done via a normal command line. The setup here was really easy, as you can just create an Expo application via npx with one command and you are pretty much good to go.

To collect the data three applications were built, all three were implemented in Flutter and React Native, making it a total of six applications to test. 

The first application was a password manager, the purpose of this app is to test regular features, which many apps have and are core features of out every da mobile device use. The implementation includes text inputs, slider inputs, button inputs, pop ups and text outputs. The app consists of two screens, one for viewing your list of passwords the other one for generating your passwords. Above the list where all passwords can be seen, the total number of passwords is shown, the amount of strong passwords and the amount of mediocore passwords. This display is not actually changing with the content in the app, so the numbers are constants which are chosen in a realistic way. The list off passwords is ordered alphabetically and if one of the items in the list is tapped, a pop-up opens, where you can see the the E-Mail adress being used along with the password and the application the password is for.

[Bild Liste Flutter und React]
[Bild Pop-Up Detail Flutter und React]

Via the navigation bar at the bottom of the application a second screen is reachable, where passwords are generated and saved. A the top of the screens there is a slider, which determines how long the password is going to be. The password can be between six and 20 characters long. Below that the amount of symbols, capital letters and digits can be determined, these values get increased or decreased by button inputs. The total number of the three inputs can not get above the value of the slider, which is checked when generating the password. In order to create a valid password the values must be adapted then. At the bottom just above the textfield where the generated password is displayed there are two buttons, one to generate a new password with the inputs from above and one to save the password. The generate button just puts the new value in the field below, while the save button opens a pop-up window.

[Bild Generating Flutter und React]

In the pop-up an E-Mail address along with an application name must be entered and on confirmation a new entry is made in the list where all the passwords are being kept.

[Bild Pop-Up Save Flutter und React]

Password Manager Flutter:

The List was realized with a seperate class, which initializes a list and implements a method to add a new element to this list. The instances of the list were also a seperate class  with all the attributes needed for the list entry, including the password the E-Mail and the application. In addition to that the class also implemented a way to get the first letter of the application the entry is meant for to be able to order the items in the list. The pop-ups were realized with alert dialogs, which are provided by Flutter. In these alert dialogs text inputs buttons and other input elements can be added. The alert dialogs are put inside a method, so the only show, when the method is called and disapear on a button click. A thing I stumbled over while implementing the app was as getting the lists refreshed when a new password was added. The problem here is only because the tab is changed in the navigation bar does not mean that the screen gets re-rendered. Only if for example a pop-up is opended, then the screen gets re-rendered and the newly added entry in the list while get displayed. So what needs to be done is, we need to create a ChangeNotifierProvider which we create for our class implementing the list and then we can call the notifyListners method in the method we add our items to the list. The notifyListeners method triggers a notification to all the listeners, that the state has changed. The widgets in our ChangeNotifierProvider listen for the notifyListener now and therefore create a reactive application. This makes sure the shown content in the app always aligns with the content in the list. The rest of the implementation is pretty straight forward. Even the slider was pretty simple as it is a component provided by Flutter and documentation is quite good on it. In addition a wide variety of icons is provided for the navigation bar, which is quite nice and just adds to the look and feel of the application. Another positive aspect about Flutter is the fact that themes are provided and they are pretty easy to use, which makes coloring decisions a lot easier and makesthe application look a lot more professional with very little effort.

Password Manager React Native:

First of all it needs to be said, that this is a Expo Go project. A later project is done with the React Native CLI approach. Sometimes the over-the-air updates were not working correctly, so on save the aplication would not reload, then the reload had to be done maually. All in all was the Expo expericence not great beceause would also be times where a complete restart of the local application was necessary. The biggest difference which jumps out directly are the styleSheets, so styling can be done kind of remotly compared to Flutter. In my personal opinion I do not like that as much, but that is just a personal preference. The application build with a Tab navigator, which displays the different tabs and below the tabs there is a bottom navigation bar, all these components are regular React Native components. The way the appliation is build with all the components and features is meant to be as close to the Flutter app as possible. The slider for adjusting the password length here is actaully a community library being supported by Expo. The slider is actually part of the expo documentation, but still is a community project, so it is an package which needs to be installed via a packet manager. For the developer this is not big of an issue though, as the documentation in the Github is pretty good and the repository is maintained pretty well. As we already discussed with Flutter we again have the same issue here with keeping our user interface consistent with the data in the list of our passwords. In order to realize reactivity in React Native we need useState and useEffect hooks. A use state sets a varibale as a state so we can re-render out components, when the variable values are changed. So every time we focus the screen where the passwords are displayed we increase a state variable counter to trigger a re-render of the screen. In our App.js we declare the list, we access in the other files via a useContext. The useContext allows us to access out list of passwords in all the other screens and also allows us to set the list, if new elemnts get added. The list is realized via a section list and pop-ups are modals with changeable visibility.

Crypto Bro:

The second application is a very basic crypto currency manager, which can display a graph and is also connected to an API. This API gets crypto news from newsdata.io, in order to able to compare the two frameworks both appliction use the the same API and perform the exact same call. The returned data may be not exactly on topic or may be a little as the free version of the API is used, but the idea behind this feature, fetching data from an API and displaying it, can be tested acuratly and with no real limitations. The screen with the crypto news can not do any more than just displaying the news in a table and open the links behind the news articles on click. The first screen in the application shows a dummy plot of cryptocurrencies. The data for the plots is completly fictional and is in no way or form corralted with real share prices. The datasets are JSON files stored in the application and read from there. Via dropdown menu there is the option to change between currencies, which then changes the plotted data in the graphs. In addition there is a print of the current value which is always just the latest datapoint in the set and a tendency, which just calculates the difference between the last and the second to last datapoint. If the second to last datapoint has a higher value than the last one then the tendency is falling, if the second to last datapoint has a lower value than the last one the tendecy is rising and if they are the same the tendency is neutral. The switche between screens is agian being done with a navigation bar fixated to the bottom of the screen. 

Crypto Bro Flutter:

The app is build with a bottom navigation bar, which is pretty similar to the password manager application. In file for ploting the data we start by loading our data from our JSON files into arrays, so we can use them in the plots. This conversion requires the package:flutter/services.dart package which can be imported from Flutter. In order to ensure reactivity for when the currency is changed via the dropdown we use the setState method of Flutter. This notifes the framework, that the value inside the dropdown has changed, and a we can redraw our graph in order to always keep it accurate with what is selected in the dropdown. In addition to the drawn data, the displayed trend also needs to adjust with a change in the dropdown menu, which is also managed via a setState. The dropdown menu itself is realized with the standard Flutter DropdownMenu. The graph is realized with a SfCartesianChart, which is provided by a third party library. The library is called syncfusion_flutter_charts, it is from the official repository for Dart and Flutter libraries and is well maintained. Documentation on this library is fairly good, eventhough it may be overwhealming at first and it takes some time to get used to and find your way through the library. The initial proccess of implementing the library was a litte difficult but the end product is actually very usable. Installation was very easy and was completed without problems. In order to perform our API call we needed package:http/http.dart in order to send an HTTPS request. The fetch method, which sends the HTTPS request, returns a Future object. What this does is it returns an obejct which eventually gets a value, but has none at the point it is actually returned. In this case we need to wait for the API to deliver the data, so the return value of this method does actually not have a value until the API response is there. In order to structure our returned data we need implement a DataModel which we put our returned data in to work with it later. The resulting data is fitted into a DataTable. If one of the entries is tapped, a browser window is opened in which the link to the atricle provided by the API is opened. The opening of the browser is actually just one method which is not even implemented by the developer rather provided by Flutter which only needs an URI to open the window. Something which may be noted here is the method needs a argument of the type URI and can not take a String which is kind of weird at first because URI can not just be casted from Strings but actually needs to be parsed.

Crypto Bro React Native:

The app is build with a NavigationContainer as the bottom navigation bar. When the news page is opened, a useEffect is called which performs the API request. The request is only performed once at the initial render of the page. The call is performed via fetch, which is a built-in API mehtod for JavaScript to make a HTTP request. With useState variables we can get the data as soon as it is returned by the API, in addition the page re-renders as soon as the data is available. The articles are just displayed over a map which creates a TouchableOpacity for every entry in the map, so for every articles the API provides. The links are open via a Linking which is provided by react-native and allows us to open a new browser window with the provided URL. The plotting screen looks works very similar, we again read all the data from the JSON files as soon as we focus the screen. JS provides us with methods to stringify and parse our JSON data. The actual chart is realized through a LineChart from react-native-chart-kit. First of all it must be said, that configurating this was more difficult than the FLutter chart. In general the lines of code to get a working chart is way higher. Two things which were an issue early was that, one the y axis changes on a re-render. So when the same chart is drawn, but all the values are ten higher, the chart looks the same if you do not look at the y-axis, which may be confusing. There are some workarounds for that but there was no possibility to just fix the y-axis. Secondly once a dataset is entered the size can not be changed even if another dataset is plotted. So for example the default dataset in the code has the size 30, all other datasets plotted need be of size 30. In general there are a lot of options and customization and documentation is not bad, but it is again just a lot to work through and example may be more scarce than wanted. So it feels like a lot of trail and error, which does hinder efficiency quite a bit. Another issue is that there were no commits onto the master branch in the Github for around two years now. Though issues are still opened, so there still is some exchange in the Github and it is also an established repository, which makes it usable for sure. The real concern here is basically only security, especially in a commercial context. It is certainly not usable as concern free as the Flutter repo we used.

Dame Game:

The last application which was implemented was a checkers game. This was implemented to check the computation capacity of the frameworks, in order to make the computations a little bit more difficult we use a 10x10 version. The app does not include anything else, it is just the checkers game, which open as soon as the application is started and when a game is finished another game just starts automatically. As there are few different versions of the game here the rules that were implemented for this version of the game. Of corse there all the standard rules like, moves can only be diagonal, own pieces can not be jumped and normal pieces can only jump one opponent or move one field forward. Crowned pieces can move all over the board, but if they beat an opponent piece they need to land right behind the other beaten piece. The uncrowned pieces can only move forward as per the rules. In general caputuring is mandatory, so if a opponent piece can be captured and the user tries to make a move, which does not lead to a capture the move is invalid and will not be permitted by the application. And a even more fine-grained implementation of that rule is also in place, where if a crowned piece can be captured, the crowned piece has to be captured. The capturing of a uncrowned piece would not be a valid move in that case. As all of these checks need to be well thought through planning and implementing the logic was the most difficult part in this application. The code is not the most optimal it can get in terms of efficiency, but should not post too much of an issue as the code for both applications is the same, so both are equally optimal which makes them comparable between each other. The highest effort in calculation is probably done, when we check if a move is valid. The problem here is that if we have a move where no piece of the opponent is captured we need to simulate all other moves in order to check if it is possible to capture an oppenent piece with another piece. So in the worst case 80 moves need to be simulated in a real scenario we probably would never need to check more than something around 60 moves. The coding experience for this application was very different in comparison to to the other two, as in the other two applications it was more about finding right components and layout these components along with styling them. Here the main focus was on the logic and making all the right checks at the right time. The Flutter application and the React Native application are both structured very similar to each other. Both have a file for the game pieces, this is more or less a model defining what a piece is and which attributes it has. Then there is a file which defines the board of the game, which returns the component for the for the game board itself as well as the array containing the game pieces. The third and final class contains all of the logic and makes all of the manipulation on the list with the game pieces. Below the board the is a text box which displays some relevant texts to the game. These texts include which player has to make a move next or which piece has been selected. In addition to that the text also notifies the user if a move is invalid and also the reason why the move is invalid. If a game has finished the text box displays the user.

Dame Game Flutter:

In the Flutter implementation the game board is definded in the main dart. The borad itself is build with a GridView which builds the 100 fields and colors them accordingly. Below the GridView there is just a standard text which displays the relevant texts. The pieces are designed by a FractionallySizedBox with the circle shape and a whith and height of 0.8. The letter for a queen is displayed with a standard text on top of the FractionallySizedBox. The GridView has a onTab property which handles all the interaction between user and application. The game piece class is pretty simple, we have a playerId which indicates which player the piece belongs to and a isQueen boolean. In addition to this the class implements a promoteToQueen method which sets the isQueen boolean and a getPlayerId, which returns the player id.

Expo vs React Native CLI:
Expo has the advantage of quick start, which makes start developing really easy without making any device specific setup.
Expo advantages
Over-the-air updates: 
Basically the equivalent to hot reload, but Native CLI has that too
Pre-built libraries:
Expo provides wide range of pre-built APIs making some features easier to implememnt
Simplified build process:
Build procces is handled for the devloper
EAS: 
With this apps can be build for IOS without having a mac
Native physical device:
You can use yout own smartphone connected via Expo to test your device
Expo disadvantages:
Limited Native Modules:
Expo restricts access to some native modules, filesystem and webview are things which are not really working in Expo
Less control over build:
As the build is automated that obviously takes away control from the developer
Size and performance:
Expo apps tend to be larger in bundle size, which can impact download and loading times

Experienced issues with Expo Go:

WebView and file system

Advantages React Native CLI:
Full Native Module Support: 
No restrictions on Native Modlues
Costumization options:
Complete build control, which gives more control to the dev
Ecosystem Compatibility:
Also full compatibility with community libraries and tools
Disadvantes React Native:
Steeper learning curve:
Takes longer to get into, also from personal experience
Longer Development Setup Time:
Native deps need to be installed and set up, so this takes time again
Manual build proccess:
Manually configure build tools, time-consuming and complex
Native Physical device:
Plattform specific device for Andriod and IOS, so you need the mac

General when Expo, when Native CLI?

Expo if:
Beginner or quick prototyping
No requirement of low-level device features
Simplicity and ease of development is important


React Native CLI if:
Need for specific native modules or third-party libraries
Extensive control over build proccess, preformance optimizations or costumization options is required
Experienced developer wanting to learn more in depth stuff

First app: Password Manager

Flutter:

Android studio setup was pretty easy as the setup was already done. The general setup is not more difficult or easy than any other IDE. Updates for the IDE were kind of weird, so that is certainly something which needs to be taken into an account. Updates need to be done manually. The big advantage of Android studio is the easy use of emulators. In combination with the hot reload feature of Flutter development is pretty easy. 

The List was realized with a list provider.

Pop-Up was realized with Alert dialog. 

Apart from that implementation was pretty straight forward.

Some logic checks were necessary for length purposes and also some checks for not letting string lengths get below 0.

The Pop-Up was a slight issue as well as getting the lists refreshed, done via listeners i think. List provider class extends changeNotifier this lets us call notifyListeners to update the list. ChangeNotifierProvider creates context from ListProvider. Is called when context is changed, so when nearest widget is changed.

App is build with Bottom navigation bar and has basically two screens, one on which you create passwords, the other where all the passwords can be viewed. The passwords are displayed in a ListView, which is sorted alphabetically. All the items in the list open a Pop-Up on tap, with information about that certain password. At the top of the list the total number of passwords is displayed along with the number of stronger passwords and medicore passwords. The primary use of this view is just the list and the Pop-Up which are both everyday uses in most applications. The second tab has a lot of UI elements, I use a slider to adjust the length of the password and buttons to modify certain aspects of the password. The modifications include the number of digits, symbols and capital letters. When saving a passowrd a E-Mail adress must be entered to also cover text input. At the bottom of the view we display the generated password. So we have a slider input, we have button inputs, we have text inputs and a text output.

The slider here is a component provided by Flutter. A certain positive here is the fact, that np outside libraries are needed, even the button icons are directly from Flutter. 

What is also very cool and very easy is the theme thing

React Native:

First of all it needs to be said, that this is a Expo Go project. A later project is done with the React Native CLI approach. Expo go setup was really easy, sometimes the over-the-air updates were not working correctly, so on save the aplication would reload, so you would have to reload manually.


The biggest difference which just out directly are the styleSheets, so styling can be done kind of remotly compared to Flutter. In my personal opinion I do not like that as much, but that is just a personal preference.  
The application build with a Tab navigator, which displays the different tabs and below the tabs there is a bottom navigation bar, all these components are regular React Native components. The way the appliation is build with all the components and features is meant to be as close to the Flutter app as possible. The slider for adjusting the password length here is actaully a community library being supported by Expo. We need use States here, and one useContext, this is for updating the data being displayed in the table with all the passwords. Also the updateData, which is basically the pendant to the notifyListeners() from Flutter, is in this file and called when ever a new password instance is created. In the file for displaying the table we have the data again, with no way to update it, as this can only be done from the generate screen. In addition to that we always group our password by their first letter, when we focus that screen, plus we udate a state variable to trigger  re-render in oder to always display the current state of the list. The list is realized with a SectionList and with the Pop-Up realized with a normal Modal