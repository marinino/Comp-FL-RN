Was war das Ziel der Arbeit?

The goal of the thesis is to compare the two mobile development frameworks Flutter and React Native. React Native is an established framework for mobile development and certainly among the most used to this point. The framework started to gain traction around 2015 and 2016 and therefore has build a pretty strong community over the years. Something that may be mentioned as a sidenote here is the fact that React Native and React.js actually have very little in common apart from the the language, so this thesis and none of the numbers can not be rated to React.js in any kind of way. Flutter has not been as popular as React Native for a long stretch, really starting to gain traction around 2019 and 2020, latest statistics may actually support the statement that Flutter is more popular now than React Native. 

According to a Statista survey Flutter usage consistently grew over the last four years from 30 to 46 percent while the usage of React Native was at 42 percent through 2019 and 2020 and then continously dropped to 32 percent in 2022. The survey was conducted worldwide and took into account many more cross-platfrom mobule frameworks. As a sidenote from this statistic it can also be derived that escpecially in 2022 the primary frameworks are Flutter and React Native by far, being used by around 78 percent of software developers worldwide. 

Looking at a different survey from Stack Overflow, which is generally revolving around frameworks and libraries used by users of Stack overflow. Looking at all respondents of the survey, which are as the thesis is conducted around 55 thousand people Flutter and React Native are virtually the same in usage with 12.64 percent for Flutter and 12.57 percent for React Native. The statistic can also be filtered to only show professional developers and only show beginners or people learning to code. Of course this categorization is very subjective and also not supervised, so this may be observed with a grain of salt, but it jumps out that in the group of people learning to code, Flutter usage is at 17.63 percent and React Native usage is at 11.39 percent. The amount of respondants for the learning to code is only at 4504 at the time, so this may also be not really representative but it certainly is something that jumps out. This effect may be explainable by the findings in this thesis and points in the same direction as this thesis goes. These statistics are all taken from the 2022 Devloper Survey by Stack Overflow, which was conducted in May. 
The same survey was done in 2023, with very similar results and a very similar amount of respondants, the only thing that really differs is that numbers for both Flutter and React Native went down eqaully.

Something which may also be worth looking at are the Google trends for the words Flutter and React Native, this is of course no real measure for quality of the frameworks but this does can certainly indicate the size of the comminuty as well as the relevacy of the frameworks. In the last twelve months the, in the context of this thesis this is the 12th of March 2023 to the 12th of March 2024, both frameworks have very constant numbers with Flutter being at a value of around 80 and React Native being at around 45, so the search interest for Flutter is roughly double of that for React Native. To put these numbers into a little context, he Google search interest is a number going from zero to 100 to indicate how relevant a topic is. Numbers from before the last twelve months are not that interesting as the frameworks move very quickly and the market is very fluent so, the is no real benefit to go further back. The only intersting thing which could be picked up from something like that is to look at when the frameworks started to become relevant, which is already mentioned above.

So with these numbers in mind and the definite knowledge that Flutter and React Native are the most used and therefore most relevant cross-platform mobile frameworks, the question arises which one is better than the other. Latest numbers may suggest, that Flutter has overtaken React Native especially in community size as the frame matured and lost its status as the new, unproven thing. Going into the task of coding and comparing the expected result is not to find a big and general verdict of one is hundred times better that the other, overall they should be fairly comparable. What could be more intersting and relevant are actually the nuonces and the different categories and scenarios in which the frameworks perform differently. In these micro scenarios, for example scrolling or rednering of different types of components, there may be some advantages which could be derived to overall findings which state that in scenario xy, Flutter may be a better choice and in another React Native has advantages.

In order to have a broad comparison and to be able to be as nuonced as possible a set of applications is developed which cover as many featrues as possible. As standard input components are part of many applications, things like text inputs or button inputs, these components need to be tested. In addition to that render speed and frames per second whilst scrolling a list are also part of many applications. From this thought the first application was chosen, the application was a simple password manager. The appplication should consist of two different screens, first the main screen, containing a simple overview of how many passwords are saved, how many of them are of strong quality and how many are of medium quality. Below that dashboard we have the actual list, the list should be an alphabetically ordered list with different section for each letter. If the user taps one of the elements in the list a pop-up should open in which details to the entry are displayed, to be precise, the application name, the password and the E-Mail adress or a user name linked to the account. On the second screen the passwords will actually be generated, at the top of this screen a range slider should be implemented, sliding between values of six and twenty, this will determine the length of the generated password. Below that slider we can determine how many capitals, number and symbols are used in the password, if all of these values are zero, the password will just consist of lower case letters. Numbers and capitals are self explenatory, the symbols are one of the following !@#$%^&*()_+{}|:;<>,.?~-=[]"\'. The number of the respective elements should be determined by button clicks. Below two buttons should be implemented, one to genrate the password with the values from above, one to save the password to the list. The first button generates the password and displays is in a textbox below. The second button should open a pop-up where the application name and the E-Mail or username can be entered. After that the entry should be stored to the stoarge of the mobile device.
The idea behind this is, as metioned above, to get as many of the standard daily features, like inputs, pop-up, textboxes, lists etc. implemented and tested for performance.

The second application which should be implemented is a a very basic crypto manager application, the implementation should only contain a bare minimum of features though, as this is more about testing graph rendering and an API integration. Again this application should consist of two screens, one where the grapg for the value of the currency is displayed and one where a list of news is provided by an API. The first screen should contain a dropdown selction menu in which the currencies can be changed, but the plots will only be of imaginary numbers, so there will be no API prividing these values, they are just randomly generated. Below the dropdown a graph should display the plot of the data, which will most likely should be done via a third party library. The second screen should just display a list of news concerning the topic of crypto, the list should contain a way to access the news, via link or iFrame or something different enabling to view the contents.
This application will test some out of the ordinary stuff, like the API connection or the rendering of the graph, in addition to that we have a dropdown which was actaully not included in the first application but could also be definded as a component which is very common and used often.

The third and last app is mainly there to measure computational power and speed of the frameworks, the implementation is a 10x10 checkers game. The application only consists of the game itslef and nothing else, part of the game should be a computer opponent as well as animations for the game pieces, so testing animations is kind of a bonus here, whcih can be tested through this. The game should be implemented with the standard checkers rule, but played on a ten by ten field and not a regular eight by eight board. By adding the computer opponent the computational cost should be higher and therefore the effects and performance should be more visible compared to just two people playing and game just checking for correctness of the actions taken.

What to measure

So in order to test performance there are a some basic measures like, frames per second druing a certain sequence of actions or memory usage as well as CPU usage.Those are all measured which will be taken in different scenarios to get a numeric understanding of how the frameworks perform. All these metrics are frequently used and therefore aslo good to make comaprisons to other studies conducted on this or similar topics. Another metric which will be interesting are the janky frames especially when scrolling through the list in the password manager or concerning the plot in the crypto application. The CPU usage will be an useful metric to compare performance for the checkers game as most stress will be on the CPU with checking correct moves, finding correct moves and executing them for the computer player, same will go for the memory as the checkers game has to store a lot of data in the memory fpr example the pieces. Frames per second will also be especially intersting, when looking at the scrolling as well as switching screens for the first two applications. For every appliaction the size and the necessary lines of codes will be looked at to gain a general idea of how large projects and executables will get. Both of thoose metrics need to be taken with some caution though as the lines of code may differ from developer to developer and code might not be optimized due to a lack of knowledge and time, so these metrics are more of an indication than a clear cut value should and should be considered as such. For the API call in the crypto application there will be a network a measure for network usage, looking into how much was used and by each framework. A metric which is also important in every day use and therefore should be measured as it can improve or worsen the user experience by a lot is the application start up time. The definition of that is the time it takes from launch until the first frame is displayed and all data is loaded, this is according to the ANdroid Developer docs.
There are also some subjective metrics that will be taken into account during the proccess. Look and feel of the apps will be one of them, for none of the apps much design work will be done. All the components will be aligned in a manerly order of course but the main focus will be on the features and functionality of the applications. Maybe despite this or even because of this the look and feel of the applications can be judged very purely, as there has not been done a lot of design work the look and feel is still very raw from the framework itself. This can play  a role when choosing a framework depending on how much capacity there is for designing and how important application design is. The developing expercience and proccess will also play a role in the evaluation of the proccess, especially when it comes to the learning curve for both frameworks as there was no real previous knowledge before implementing the applications.

How to measure

Measurements will be done on physical devices, as testing on emulators is discurraged by both Flutter and React Native. Flutter says in its docs, that performance profiling results from an emulator will not be the same as running the application in the profile mode on a physical device. The applications will be tested on a iOS phone and on a Android phone. It is suggested to use lower level phones in order to see better effects while profiling, using the latest models for each plattform would probably result in minimal stress on the devices and therefore in minimal difference in the results. So in this case it is less about ensuring a good user experience on a lower level phone, which this would be about in a commercial context, but more about seeing actual differences in numbers. The iOS phone of choice will be an iPhone 8 and the android phone will be a Nokia C12. Finding the rigth way to profile the performance and all the metrics turned out to be a bigger struggle than expected, actually for the IOS side things are easier there. When deploying and application from XCode, the standard development tool on the apple plattform there is a plattform called Xcode instruments with which you can profile any application running on any device connected to a macbook or the macbook itself. After starting up the application, it needs to be selected as the application to measure and then CPU usage, FPS, disc usage, etc. can recorded. This works both for Flutter and React Native. This means all the Flutter applications plus the sole React Native application for IOS will be tested with Xcode instuments. Now the React Native via Expo Go apllications will be tested with Flashlight and the included performance monitor. Flashlight is a tool for profiling application performance, monitoring frames per second, RAM and CPU usage. This approach is used, as it provides the advantage of the application being deployed on a Windows operating system for the IPhone, which is very useful in this case as for the proccess of the thesis the access to a MacBook is limited and there is no experience with the MacOs operating system, so the most work is preferred to be done on a Windows device. The easiest way to measure is probably the Flutter framework on Android as there is a FLutter profiler which gives a lot of information about the application similar to xcode instruments on the MacBook. The Flutter profiler is the recommended tool in the FLutter docs and therefore will be used with no additional tools being needed, at least at the point of planning the whole proccess. React Native on windwos will be monitored by Flashlight, the Android Studio Profiler and the React Native Performance Monitor. This decision is made because all of the tools by themselves would not paint a clear enough picture and give all the information needed to satisfy our numeric metrics so the tool will work hand in hand.

Measuring scenarios

In order to make sure that the experiments are reproducable and there is some structure to the measuring proccess we define some scenrios which we run through to forge out data.

For the crypto app we have the follwoing scenarios:

C1:
	- Open up app
	- Switch to currency Etherum
	- Switch to currency XPR
	- Switch to currency Dash
	- Switch to currecny Stellar

We just go through all the currencies and let the application plot the graph for the ones listed, as this is one of the main features we want to test in this application and a core part of our data collection.
After every switch of currency there is a arounf two second long wait as the usual scenario would be to take at least a qiuck look at the graph when opening it up.

C2:
	- Open up app
	- Switch to Etherum 
	- Switch to XPR

Here we simulate a misclick in the dropdown menu where we select the currency, so we have an instant switch between the currencies and see how that is handled by each framework.
Make instant switch between the two currencies to simulate a misclick.

C3:
 	- Open up app 
	- Switch to News screen
	- Click on the top news
	- Return to app
	- Click on the second news
	- Switch back to Plots

Here we basically want to simulate the basic usage for the news screen, where the user opens news from the list and reads through them.
Have the news open for a few seconds.

C4:
	- Open up app
	- Switch to news screen
	- Switch to plots

Here we want to simulate a fast switch between the screens in the bottom navigation bar, in this scenario the users change to the news screen was not intended
Simulate mistake of on accidently changing screen, so switch of screens is instant.

Password Manager:

PM1:
	- Open up app 
	- Select top most passwort
	- Close it

Again this first scenario is probably the standard use case for this application, where the user looks up a password to type in.
Simulates looking up a password, closing should be 8 seconds after opening, so password will actually be looked at.

PM2:
	- Open up app 
	- Select top most password
	- Close it
	- Open second password
	- Close it

Here we simulate the scenario that the user opens up the wrong password and after that the right one.
Simulates looking up a password, chooses wrong one, so closes it instantly and then selects the second one, closing that should be 8 seconds after opening, so password will actually be looked at.

PM3:
	- Open up app 
	- Scroll to bottom
	- Open last password
	- Close it

Here we simulate the very important scrolling effect, to have a representative result we should have at least ten passwords in our list.
Simulates scroll effect, then opening password, closing that should be 8 seconds after opening, so password will actually be looked at.

PM4:
	- Open up app
	- Switch to generate screen
	- Switch to home

Again we check for an accidental change of screen just like in C4.
Simulate mistake of on accidently changing screen, so switch of screens is instant.

PM5:
	- Open up app
	- Switch to generate screen
	- Create password of length 8, 2 digits, 3 caps, 1 symbol
	- Save password [Application: TestObject1, EMail: test.@mail.com]

This is about the second most important feature of the application, generating and saving passwords, here is where disk write speed comes into play.
Create a short password.

PM6:
	- Open up app
	- Switch to generate screen
	- Create password of length 20, 8 digits, 6 caps, 5 symbol
	- Save password [Application: TestObject1, EMail: test.@mail.com]

Same as PM5, just with a longer password, to check if anything is different if passwords are longer.
Create a long password.

PM7:
	- Open up app
	- Switch to generate screen
	- Generate password of length 8, 6 digits, 6 caps, 6 symbol
	
Here we check the performance when the generating is aborted as the password is invalid.
Generate invalid password.

Checkers:

Here we go a different route, as the testing for this application consists of nothing more but playing the checkers game, we spefify the amount of games which shoild be played and certain scenarios which should accur at least once during those ten games in order to get a representative result of the performance of the whole application.

	- Play 10 games	
	- Must happen scenarios:
		- White piece moves bottom left, bottom right,
		- Black piece moves top left and top right
		- White piece beats bottom left, bottom right
		- Black piece beats top left and top right
		- White piece gets crowned bottom left, bottom right
		- Black piece gets crowned top left and top right
		- White piece tries not jump on non-empty field
		- White piece tries to jump an empty field
		- White piece tries to make non-diagonal move
		- White piece ignores beating piece
		- White piece removes selection of stone
		- White non-crowned piece tries to move top left
		- White non-crowned piece tries to move top right
		- White piece tries to jump won piece
		- White crowned piece moves top left, top right bottom left and bottom right
		- Black crowned piece moves top left, top right bottom left and bottom right
		- White crowned piece beats top left, top right bottom left and bottom right
		- Black crowned piece beats top left, top right bottom left and bottom right
		- White crowned piece tries not jump on non-empty field
		- White crowned piece tries to jump an empty field
		- White crowned piece tries to make non-diagonal move
		- White crowned piece ignores beating piece
		- White crowned piece removes selection of stone
		- At least one double beating 
		- White wins
		- Black wins







Flutter on Windows will be measured with the Flutter dev tools
React Native on Windows will be measured by Flashlight
Flutter and React Native on IOS with XCode instruments

Measuring RAM in MB
Measuring CPU in %
FPS in frames w/ Janky frames in frames
Code length
Application size
Network speed for API [HOW TO TEST]
App start up test [CAN BE AN OPTION SHOULD BE TESTED]



